# -*- coding: utf-8 -*-
"""MetodosQuaseNewton.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19iY8XiTm7YpaJzuNIeglbY6Cw0VpnbI7
"""

import numpy as np

"""## Funções Teste"""

#Função quadrática

def quadratica(X):
  f = 0
  for i in range(len(X)):
    f = f + (i+1)*X[i]**2
  return f


def gradienteQ(X):
  Y = np.zeros(len(X))
  for i in range (len(X)):
    Y[i] = 2*(i+1)*X[i]
  return Y

#Função Rosenbrock

def rosenbrock(X):
    return np.sum(100 * (X[1:] - X[:-1]**2)**2 + (1 - X[:-1])**2)


def gradienteR(X):
    Y = np.zeros_like(X)

    Y[0] = -400 * X[0] * (X[1] - X[0]**2) - 2 * (1 - X[0])
    Y[1:-1] = 200 * (X[1:-1] - X[:-2]**2) - 400 * X[1:-1] * (X[2:] - X[1:-1]**2) - 2 * (1 - X[1:-1])
    Y[-1] = 200 * (X[-1] - X[-2]**2)

    return Y

#Styblinsky-Tang

def styblinsky(X):
  f = np.sum(X**4 - 16*X**2 + 5*X)
  return f


#Gradiente Styblinsky-Tang

def gradienteS(X):
  Y = 4*X**3 - 32*X + 5
  return Y

#Rastrigin

def rastrigin(X):
  f = np.sum(X**2 - 10*np.cos(2*np.pi*X))
  return f

def gradienteRa(X):
  Y = 2*X + 20*np.pi*np.sin(2*np.pi*X)
  return Y

"""## Algoritmos de Minimização

Para mudar a função teste dos algoritmos abaixo, deve-se substituir as funções gradiente e a da função nos lugares indicados
"""

#Algoritmo CP1

def CP1(n, X):

#Definições de constantes e inicialização

  alpha = 10e-4
  beta = 10e-3
  gama = 10e-6
  sigma = 0.5
  epsilon = 1.e-16
  M = 10000
  H = np.identity(n)
  k = 0
  grad = gradienteR(X)                                          #Gradiente da função teste
  g_norm = np.linalg.norm(grad)

#Algoritmo

  while(g_norm >= epsilon and k < M):
    d = (-1)* np.matmul(H,grad)
    d_norm = np.linalg.norm(d)

    if(np.dot(grad,d) > -gama*(d_norm)):
      d = (-1)*grad
      d_norm = np.linalg.norm(d)
      H = np.identity(n)

    if(d_norm < beta*g_norm):
      d = beta*(g_norm/d_norm)*d

    t = 1
    while(rosenbrock(X+t*d) > rosenbrock(X)):                      #Função teste
      t = sigma*t

    X_ant = X
    X = X + t*d
    s = X - X_ant
    y = gradienteR(X) - grad                                    #Gradiente da função teste
    z = np.matmul(H,y)
    w = s - z

    if(np.dot(w,y) > 0):
      H = H + (np.outer(w,w)/np.dot(w,y))

    k = k + 1
    grad = gradienteR(X)                                        #Gradiente da função teste
    g_norm = np.linalg.norm(grad)

  print('CP1 concluido em ', k, ' iterações')
  return (X)

#Algoritmo DFP

def DFP(n, X):

#Definições de constante e inicialização

  alpha = 10e-4
  beta = 10e-3
  gama = 10e-6
  sigma = 0.5
  epsilon = 1.e-16
  M = 10000
  H = np.identity(n)
  k = 0
  grad = gradienteR(X)                                                  #Gradiente da função teste
  g_norm = np.linalg.norm(grad)

#Algoritmo

  while(g_norm >= epsilon and k < M):
    d = (-1)* np.matmul(H,grad)
    d_norm = np.linalg.norm(d)

    if(np.dot(grad,d) > -gama*(d_norm)):
      d = (-1)*grad
      d_norm = np.linalg.norm(d)
      H = np.identity(n)

    if(d_norm < beta*g_norm):
      d = beta*(g_norm/d_norm)*d

    t = 1
    while(rosenbrock(X+t*d) > rosenbrock(X)):                             #Função teste
      t = sigma*t

    X_ant = X
    X = X + t*d
    s = X - X_ant
    y = gradienteR(X) - grad                                           #Gradiente da função teste
    z = np.matmul(H,y)
    w = s - z

    if(np.dot(s,y) > 0):
      H = H + (np.outer(s,s)/np.dot(s,y)) - (np.outer(z,z)/np.dot(z,y))

    k = k + 1
    grad = gradienteR(X)                                               #Gradiente da função teste
    g_norm = np.linalg.norm(grad)

  print('DFP concluido em ', k, ' iterações')
  return (X)

"""## Testes"""

# n é tamanho do vetor X que iremos usar no teste

n = 10

#np.random.seed(10)
#X = np.random.randint(-10,10, size = n)
X = np.random.rand(n)
X

X_estrela1 = CP1(len(X),X)
print('x* =', X_estrela1)
print('f(x*) = ', rosenbrock(X_estrela1))

print('//////////////////')

X_estrela2 = DFP(len(X),X)
print('x* =', X_estrela2)
print('f(x*) = ', rosenbrock(X_estrela2))

